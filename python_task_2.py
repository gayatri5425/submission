# -*- coding: utf-8 -*-
"""python_task_2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BelPU_iw61OfbsPbpNjgzHViij2O6KRA
"""

import pandas as pd

path="/content/dataset-3.csv"
df = pd.read_csv(path)
df

df.head()

df.isnull().sum()

# Question 1

import pandas as pd

def calculate_distance_matrix(df):

    # Create an empty matrix with unique IDs as both index and columns
    unique_ids = sorted(set(df['id_start']).union(df['id_end']))
    distance_matrix = pd.DataFrame(index=unique_ids, columns=unique_ids, dtype=float)

    # Initialize the matrix with 0 for diagonal elements
    for id_val in unique_ids:
        distance_matrix.loc[id_val, id_val] = 0

    # Fill in the matrix with cumulative distances along known routes
    for row in df.itertuples(index=False):
        id_start, id_end, distance = row
        distance_matrix.loc[id_start, id_end] = distance
        distance_matrix.loc[id_end, id_start] = distance  # Symmetric matrix

    # Calculate cumulative distances
    for k in unique_ids:
        for i in unique_ids:
            for j in unique_ids:
                # If there is a known route from i to k and from k to j
                if not pd.isna(distance_matrix.loc[i, k]) and not pd.isna(distance_matrix.loc[k, j]):
                    # If there is no known route from i to j or the new route is shorter
                    if pd.isna(distance_matrix.loc[i, j]) or (distance_matrix.loc[i, k] + distance_matrix.loc[k, j] < distance_matrix.loc[i, j]):
                        # Update the distance
                        distance_matrix.loc[i, j] = distance_matrix.loc[i, k] + distance_matrix.loc[k, j]

    return distance_matrix

# Question 2

import pandas as pd

def unroll_distance_matrix(distance_matrix):

    # Create an empty list to store unrolled data
    unrolled_data = []

    # Iterate over the rows and columns of the distance matrix
    for id_start in distance_matrix.index:
        for id_end in distance_matrix.columns:
            # Skip diagonal elements
            if id_start != id_end:
                # Append data to the list
                unrolled_data.append({
                    'id_start': id_start,
                    'id_end': id_end,
                    'distance': distance_matrix.at[id_start, id_end]
                })

    # Create a DataFrame from the unrolled data
    unrolled_df = pd.DataFrame(unrolled_data)

# Question 3

import pandas as pd

def find_ids_within_ten_percentage_threshold(distance_matrix, reference_id):

    # Filter rows corresponding to the reference ID
    reference_row = distance_matrix.loc[reference_id]

    # Calculate the average distance for the reference ID
    average_distance = reference_row.mean()

    # Calculate the threshold range (10%)
    threshold_range = 0.1 * average_distance

    # Find IDs within the threshold range
    ids_within_threshold = reference_row[(reference_row >= average_distance - threshold_range) &
                                         (reference_row <= average_distance + threshold_range)]

    # Sort the IDs and convert to a list
    sorted_ids_within_threshold = sorted(ids_within_threshold.index.tolist())

    return sorted_ids_within_threshold

# Question 4

import pandas as pd

def calculate_toll_rate(df):
    # Copy the input DataFrame to avoid modifying the original
    result_df = df.copy()

    # Define rate coefficients for each vehicle type
    rate_coefficients = {'moto': 0.8, 'car': 1.2, 'rv': 1.5, 'bus': 2.2, 'truck': 3.6}

    # Calculate toll rates for each vehicle type
    for vehicle_type, rate_coefficient in rate_coefficients.items():
        result_df[vehicle_type] = result_df['distance'] * rate_coefficient

    return result_df
data = {'id_start': [1001400, 1001402, 1001404],
        'id_end': [1001402, 1001404, 1001406],
        'distance': [9.7, 20.2, 16.0]}

example_df = pd.DataFrame(data)

# Calculate toll rates for the example DataFrame
result_df = calculate_toll_rate(example_df)

# Display the resulting DataFrame in table format
print(result_df.to_markdown(index=False))

#Question 5

import pandas as pd
from datetime import time, timedelta

def calculate_time_based_toll_rates(df):

    # Copy the input DataFrame to avoid modifying the original
    result_df = df.copy()

    # Define time ranges and discount factors
    time_ranges = {
        'weekday_morning': (time(0, 0), time(10, 0)),
        'weekday_afternoon': (time(10, 0), time(18, 0)),
        'weekday_evening': (time(18, 0), time(23, 59, 59)),
        'weekend_all_day': (time(0, 0), time(23, 59, 59)),
    }

    discount_factors = {
        'weekday_morning': 0.8,
        'weekday_afternoon': 1.2,
        'weekday_evening': 0.8,
        'weekend_all_day': 0.7,
    }

    # Create new columns for start_day, start_time, end_day, and end_time
    result_df['start_day'] = 'Monday'
    result_df['end_day'] = 'Sunday'
    result_df['start_time'] = time(0, 0)
    result_df['end_time'] = time(23, 59, 59)

    # Calculate time-based toll rates for each time range
    for time_range, (start_time, end_time) in time_ranges.items():
        mask = (result_df['start_time'] >= start_time) & (result_df['end_time'] <= end_time)
        mask_weekend = mask & (result_df['start_day'].isin(['Saturday', 'Sunday']))

        # Apply discount factors based on time range
        for vehicle_type in ['moto', 'car', 'rv', 'bus', 'truck']:
            result_df.loc[mask & ~mask_weekend, vehicle_type] *= discount_factors[time_range]
            result_df.loc[mask_weekend, vehicle_type] *= discount_factors['weekend_all_day']

    return result_df
    result_df = calculate_time_based_toll_rates(example_df)

# Display the resulting DataFrame in table format
print(result_df.to_markdown(index=False))